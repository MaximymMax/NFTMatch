<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Поиск монохромных NFT</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        @import url('styles.css');
    </style>
</head>
<body>
    <div id="app" class="container">
        <header class="text-center mb-8">
            <h1>NFT Match</h1>
        </header>
        <nav aria-label="Tabs">
            <button class="tab-btn active" data-tab="background-finder">
                <span class="tab-title">Фоны</span>
            </button>
            <button class="tab-btn" data-tab="model-finder">
                <span class="tab-title">Модели</span>
            </button>
        </nav>
        <main>
            <!-- Tab 1: Coefficient -->
            <div id="monochrome-coefficient" class="tab-content hidden">
                <h2>1. Определить коэффициент монохромности</h2>
                <div class="p-6">
                    <input type="url" id="nftUrlInput" placeholder="https://t.me/nft/..." class="dropdown-input" style="width:100%;">
                    <div id="nftUrlStatus" class="mt-2 text-sm text-center"></div>
                    <div id="monochromeResult" class="mt-6 text-center h-24 flex items-center justify-center">
                        <span class="text-muted">Результат анализа появится здесь</span>
                    </div>
                </div>
            </div>
            <!-- Tab 2: Background Finder -->
            <div id="background-finder" class="tab-content">
                <h2>Сочетающиеся фоны для модели</h2>
                <div class="p-6">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <label class="block mb-2 text-sm font-medium text-text-secondary">Тип подарка:</label>
                            <div id="bgFinderGiftTypeDropdown" class="searchable-dropdown"></div>
                        </div>
                        <div>
                            <label class="block mb-2 text-sm font-medium text-text-secondary">Модель подарка:</label>
                            <div id="bgFinderModelDropdown" class="searchable-dropdown"></div>
                        </div>
                    </div>
                    <div id="giftPreview" class="hidden">
                        <div id="modelStatus" class="text-center"></div>
                        <div class="gift-preview-container">
                            <img id="giftPreviewImage" src="" alt="Gift Preview" class="rounded-lg w-full" crossorigin="anonymous">
                            <canvas id="colorCanvas" class="hidden"></canvas>
                        </div>
                        <div id="targetColorsDisplay" class="target-color-display"></div>
                    </div>
                </div>
                <div id="backgroundResults" class="grid"></div>
            </div>
            <!-- Tab 3: Model Finder -->
            <div id="model-finder" class="tab-content hidden">
                <h2>Сочетающиеся модели для фона</h2>
                <div class="p-6">
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <label class="block mb-2 text-sm font-medium text-text-secondary">Тип подарка:</label>
                            <div id="modelFinderGiftTypeDropdown" class="searchable-dropdown"></div>
                        </div>
                        <div>
                            <label class="block mb-2 text-sm font-medium text-text-secondary">Цвет фона:</label>
                            <div id="modelFinderColorDropdown" class="searchable-dropdown"></div>
                        </div>
                    </div>
                    <div class="pt-2">
                        <label class="form-switch">
                            <input type="checkbox" id="monocolorOnlyCheckbox" checked>
                            <span>Учитывать только одноцветные</span>
                        </label>
                    </div>
                </div>
                <div id="modelResults" class="grid"></div>
            </div>
        </main>
    </div>
    <div id="cardModalOverlay" class="card-modal-overlay" style="display:none;">
        <div class="card-modal" id="cardModalContent">
            <div class="modal-header">
                <button class="close-modal-btn" id="closeModalBtn" aria-label="Закрыть">&times;</button>
            </div>
            
            <div class="modal-body" id="modalBodyContent">
                </div>
        </div>
    </div>
<script>
try { window.Telegram?.WebApp?.ready(); window.Telegram?.WebApp?.expand(); } catch (e) { console.error("TG SDK Error", e); }

    
    // --- Test Data ---
    const fixedColors = [
        { id: 'Amber', name: 'Amber', hex: '#DAB345', gradient: 'radial-gradient(circle, rgb(218, 179, 69) 0%, rgb(177, 128, 42) 100%)' },
        { id: 'Aquamarine', name: 'Aquamarine', hex: '#60B195', gradient: 'radial-gradient(circle, rgb(96, 177, 149) 0%, rgb(70, 171, 180) 100%)' },
        { id: 'AzureBlue', name: 'AzureBlue', hex: '#5DB1CB', gradient: 'radial-gradient(circle, rgb(93, 177, 203) 0%, rgb(68, 139, 171) 100%)' },
        { id: 'BattleshipGrey', name: 'BattleshipGrey', hex: '#8C8C85', gradient: 'radial-gradient(circle, rgb(140, 140, 133) 0%, rgb(108, 108, 102) 100%)' },
        { id: 'Black', name: 'Black', hex: '#363738', gradient: 'radial-gradient(circle, rgb(54, 55, 56) 0%, rgb(14, 15, 15) 100%)' },
        { id: 'Burgundy', name: 'Burgundy', hex: '#A35E66', gradient: 'radial-gradient(circle, rgb(163, 94, 102) 0%, rgb(109, 65, 74) 100%)' },
        { id: 'BurntSienna', name: 'BurntSienna', hex: '#D66F3C', gradient: 'radial-gradient(circle, rgb(214, 111, 60) 0%, rgb(181, 75, 45) 100%)' },
        { id: 'CamoGreen', name: 'CamoGreen', hex: '#75944D', gradient: 'radial-gradient(circle, rgb(117, 148, 77) 0%, rgb(84, 115, 65) 100%)' },
        { id: 'Cappuccino', name: 'Cappuccino', hex: '#B1907E', gradient: 'radial-gradient(circle, rgb(177, 144, 126) 0%, rgb(124, 99, 86) 100%)' },
        { id: 'Caramel', name: 'Caramel', hex: '#D09932', gradient: 'radial-gradient(circle, rgb(208, 153, 50) 0%, rgb(183, 116, 49) 100%)' },
        { id: 'Carmine', name: 'Carmine', hex: '#E0574A', gradient: 'radial-gradient(circle, rgb(224, 87, 74) 0%, rgb(168, 56, 59) 100%)' },
        { id: 'CarrotJuice', name: 'CarrotJuice', hex: '#DB9867', gradient: 'radial-gradient(circle, rgb(219, 152, 103) 0%, rgb(199, 111, 79) 100%)' },
        { id: 'CelticBlue', name: 'CelticBlue', hex: '#49B8ED', gradient: 'radial-gradient(circle, rgb(69, 184, 237) 0%, rgb(56, 134, 217) 100%)' },
        { id: 'Chestnut', name: 'Chestnut', hex: '#BE6F54', gradient: 'radial-gradient(circle, rgb(190, 111, 84) 0%, rgb(153, 72, 56) 100%)' },
        { id: 'Chocolate', name: 'Chocolate', hex: '#A46E58', gradient: 'radial-gradient(circle, rgb(164, 110, 88) 0%, rgb(116, 68, 59) 100%)' },
        { id: 'CobaltBlue', name: 'CobaltBlue', hex: '#6088CF', gradient: 'radial-gradient(circle, rgb(96, 136, 207) 0%, rgb(81, 98, 184) 100%)' },
        { id: 'Copper', name: 'Copper', hex: '#D08656', gradient: 'radial-gradient(circle, rgb(208, 134, 86) 0%, rgb(157, 101, 49) 100%)' },
        { id: 'CoralRed', name: 'CoralRed', hex: '#DA896B', gradient: 'radial-gradient(circle, rgb(218, 137, 107) 0%, rgb(196, 101, 79) 100%)' },
        { id: 'Cyberpunk', name: 'Cyberpunk', hex: '#858BF3', gradient: 'radial-gradient(circle, rgb(133, 143, 243) 0%, rgb(134, 95, 211) 100%)' },
        { id: 'DarkGreen', name: 'DarkGreen', hex: '#516341', gradient: 'radial-gradient(circle, rgb(81, 99, 65) 0%, rgb(43, 69, 47) 100%)' },
        { id: 'DarkLilac', name: 'DarkLilac', hex: '#B17DA5', gradient: 'radial-gradient(circle, rgb(177, 125, 165) 0%, rgb(140, 87, 122) 100%)' },
        { id: 'DeepCyan', name: 'DeepCyan', hex: '#31B5AA', gradient: 'radial-gradient(circle, rgb(49, 181, 170) 0%, rgb(24, 149, 153) 100%)' },
        { id: 'DesertSand', name: 'DesertSand', hex: '#B39F82', gradient: 'radial-gradient(circle, rgb(179, 159, 130) 0%, rgb(126, 115, 91) 100%)' },
        { id: 'ElectricIndigo', name: 'ElectricIndigo', hex: '#A980F3', gradient: 'radial-gradient(circle, rgb(169, 128, 243) 0%, rgb(91, 98, 216) 100%)' },
        { id: 'ElectricPurple', name: 'ElectricPurple', hex: '#CA70C6', gradient: 'radial-gradient(circle, rgb(202, 112, 198) 0%, rgb(150, 98, 212) 100%)' },
        { id: 'Emerald', name: 'Emerald', hex: '#78C585', gradient: 'radial-gradient(circle, rgb(120, 197, 133) 0%, rgb(66, 161, 113) 100%)' },
        { id: 'EnglishViolet', name: 'EnglishViolet', hex: '#B186BB', gradient: 'radial-gradient(circle, rgb(177, 134, 187) 0%, rgb(135, 90, 145) 100%)' },
        { id: 'Fandango', name: 'Fandango', hex: '#E28AB6', gradient: 'radial-gradient(circle, rgb(226, 138, 182) 0%, rgb(164, 88, 139) 100%)' },
        { id: 'Feldgrau', name: 'Feldgrau', hex: '#899288', gradient: 'radial-gradient(circle, rgb(137, 146, 136) 0%, rgb(94, 107, 99) 100%)' },
        { id: 'FireEngine', name: 'FireEngine', hex: '#F05F4F', gradient: 'radial-gradient(circle, rgb(240, 95, 79) 0%, rgb(196, 57, 73) 100%)' },
        { id: 'FrenchBlue', name: 'FrenchBlue', hex: '#5C9BC4', gradient: 'radial-gradient(circle, rgb(92, 155, 196) 0%, rgb(55, 115, 154) 100%)' },
        { id: 'FrenchViolet', name: 'FrenchViolet', hex: '#C260E6', gradient: 'radial-gradient(circle, rgb(194, 96, 230) 0%, rgb(145, 78, 217) 100%)' },
        { id: 'Grape', name: 'Grape', hex: '#9D73C1', gradient: 'radial-gradient(circle, rgb(157, 116, 193) 0%, rgb(121, 77, 160) 100%)' },
        { id: 'Gunmetal', name: 'Gunmetal', hex: '#4C5D63', gradient: 'radial-gradient(circle, rgb(76, 93, 99) 0%, rgb(47, 59, 66) 100%)' },
        { id: 'GunshipGreen', name: 'GunshipGreen', hex: '#558A65', gradient: 'radial-gradient(circle, rgb(85, 138, 101) 0%, rgb(61, 102, 87) 100%)' },
        { id: 'HunterGreen', name: 'HunterGreen', hex: '#8FA078', gradient: 'radial-gradient(circle, rgb(143, 174, 120) 0%, rgb(75, 130, 91) 100%)' },
        { id: 'IndigoDye', name: 'IndigoDye', hex: '#537991', gradient: 'radial-gradient(circle, rgb(83, 121, 145) 0%, rgb(65, 100, 121) 100%)' },
        { id: 'IvoryWhite', name: 'IvoryWhite', hex: '#BABAD1', gradient: 'radial-gradient(circle, rgb(186, 182, 177) 0%, rgb(161, 157, 151) 100%)' },
        { id: 'JadeGreen', name: 'JadeGreen', hex: '#55C49C', gradient: 'radial-gradient(circle, rgb(85, 196, 156) 0%, rgb(59, 153, 119) 100%)' },
        { id: 'KhakiGreen', name: 'KhakiGreen', hex: '#ADAE70', gradient: 'radial-gradient(circle, rgb(173, 176, 112) 0%, rgb(107, 125, 84) 100%)' },
        { id: 'Lavender', name: 'Lavender', hex: '#B789E4', gradient: 'radial-gradient(circle, rgb(183, 137, 228) 0%, rgb(138, 90, 188) 100%)' },
        { id: 'Lemongrass', name: 'Lemongrass', hex: '#AEB85A', gradient: 'radial-gradient(circle, rgb(174, 184, 90) 0%, rgb(85, 147, 69) 100%)' },
        { id: 'LightOlive', name: 'LightOlive', hex: '#C2AF64', gradient: 'radial-gradient(circle, rgb(194, 175, 100) 0%, rgb(136, 126, 69) 100%)' },
        { id: 'Malachite', name: 'Malachite', hex: '#95B457', gradient: 'radial-gradient(circle, rgb(149, 180, 87) 0%, rgb(61, 151, 85) 100%)' },
        { id: 'MarineBlue', name: 'MarineBlue', hex: '#4E689C', gradient: 'radial-gradient(circle, rgb(78, 104, 156) 0%, rgb(59, 75, 122) 100%)' },
        { id: 'MexicanPink', name: 'MexicanPink', hex: '#E36692', gradient: 'radial-gradient(circle, rgb(227, 102, 146) 0%, rgb(201, 73, 124) 100%)' },
        { id: 'MidnightBlue', name: 'MidnightBlue', hex: '#5C6985', gradient: 'radial-gradient(circle, rgb(92, 105, 133) 0%, rgb(53, 64, 87) 100%)' },
        { id: 'MintGreen', name: 'MintGreen', hex: '#7ECA82', gradient: 'radial-gradient(circle, rgb(126, 203, 130) 0%, rgb(69, 158, 90) 100%)' },
        { id: 'Moonstone', name: 'Moonstone', hex: '#7EB1B4', gradient: 'radial-gradient(circle, rgb(126, 177, 180) 0%, rgb(88, 131, 144) 100%)' },
        { id: 'Mustard', name: 'Mustard', hex: '#D4980D', gradient: 'radial-gradient(circle, rgb(212, 152, 13) 0%, rgb(196, 119, 18) 100%)' },
        { id: 'MysticPearl', name: 'MysticPearl', hex: '#D08B6D', gradient: 'radial-gradient(circle, rgb(208, 139, 109) 0%, rgb(176, 87, 112) 100%)' },
        { id: 'NavyBlue', name: 'NavyBlue', hex: '#6C9EDD', gradient: 'radial-gradient(circle, rgb(108, 158, 221) 0%, rgb(92, 110, 201) 100%)' },
        { id: 'NeonBlue', name: 'NeonBlue', hex: '#7596F9', gradient: 'radial-gradient(circle, rgb(117, 150, 249) 0%, rgb(104, 98, 228) 100%)' },
        { id: 'OldGold', name: 'OldGold', hex: '#B58D38', gradient: 'radial-gradient(circle, rgb(181, 141, 56) 0%, rgb(148, 105, 37) 100%)' },
        { id: 'OnyxBlack', name: 'OnyxBlack', hex: '#4D5254', gradient: 'radial-gradient(circle, rgb(77, 82, 84) 0%, rgb(49, 54, 56) 100%)' },
        { id: 'Orange', name: 'Orange', hex: '#D19A3A', gradient: 'radial-gradient(circle, rgb(209, 154, 58) 0%, rgb(192, 111, 71) 100%)' },
        { id: 'PacificCyan', name: 'PacificCyan', hex: '#5ABEA6', gradient: 'radial-gradient(circle, rgb(90, 190, 166) 0%, rgb(61, 149, 186) 100%)' },
        { id: 'PacificGreen', name: 'PacificGreen', hex: '#6FC793', gradient: 'radial-gradient(circle, rgb(111, 199, 147) 0%, rgb(59, 156, 132) 100%)' },
        { id: 'Persimmon', name: 'Persimmon', hex: '#E7A75A', gradient: 'radial-gradient(circle, rgb(231, 167, 90) 0%, rgb(197, 103, 95) 100%)' },
        { id: 'PineGreen', name: 'PineGreen', hex: '#6DA97C', gradient: 'radial-gradient(circle, rgb(107, 169, 124) 0%, rgb(62, 121, 112) 100%)' },
        { id: 'Pistachio', name: 'Pistachio', hex: '#97B07C', gradient: 'radial-gradient(circle, rgb(151, 176, 124) 0%, rgb(92, 129, 76) 100%)' },
        { id: 'Platinum', name: 'Platinum', hex: '#B2AEAD', gradient: 'radial-gradient(circle, rgb(178, 174, 167) 0%, rgb(136, 132, 126) 100%)' },
        { id: 'PureGold', name: 'PureGold', hex: '#CCAB41', gradient: 'radial-gradient(circle, rgb(204, 171, 65) 0%, rgb(152, 123, 50) 100%)' },
        { id: 'Purple', name: 'Purple', hex: '#AE6EAE', gradient: 'radial-gradient(circle, rgb(174, 108, 174) 0%, rgb(132, 71, 132) 100%)' },
        { id: 'RangerGreen', name: 'RangerGreen', hex: '#5F7849', gradient: 'radial-gradient(circle, rgb(95, 120, 73) 0%, rgb(60, 79, 59) 100%)' },
        { id: 'Raspberry', name: 'Raspberry', hex: '#E07B85', gradient: 'radial-gradient(circle, rgb(224, 123, 133) 0%, rgb(182, 89, 128) 100%)' },
        { id: 'RifleGreen', name: 'RifleGreen', hex: '#64695C', gradient: 'radial-gradient(circle, rgb(100, 105, 92) 0%, rgb(75, 82, 65) 100%)' },
        { id: 'RomanSilver', name: 'RomanSilver', hex: '#A3A8B5', gradient: 'radial-gradient(circle, rgb(163, 168, 181) 0%, rgb(124, 128, 138) 100%)' },
        { id: 'Rosewood', name: 'Rosewood', hex: '#B77A77', gradient: 'radial-gradient(circle, rgb(183, 122, 119) 0%, rgb(129, 76, 82) 100%)' },
        { id: 'Sapphire', name: 'Sapphire', hex: '#58A3C8', gradient: 'radial-gradient(circle, rgb(88, 163, 200) 0%, rgb(83, 121, 194) 100%)' },
        { id: 'SatinGold', name: 'SatinGold', hex: '#BF9B47', gradient: 'radial-gradient(circle, rgb(191, 155, 71) 0%, rgb(141, 119, 57) 100%)' },
        { id: 'SealBrown', name: 'SealBrown', hex: '#664D45', gradient: 'radial-gradient(circle, rgb(102, 77, 69) 0%, rgb(71, 54, 46) 100%)' },
        { id: 'ShamrockGreen', name: 'ShamrockGreen', hex: '#8AB163', gradient: 'radial-gradient(circle, rgb(138, 177, 99) 0%, rgb(85, 147, 69) 100%)' },
        { id: 'SilverBlue', name: 'SilverBlue', hex: '#80A4B8', gradient: 'radial-gradient(circle, rgb(128, 164, 184) 0%, rgb(96, 124, 145) 100%)' },
        { id: 'SkyBlue', name: 'SkyBlue', hex: '#58B4C8', gradient: 'radial-gradient(circle, rgb(88, 180, 200) 0%, rgb(83, 139, 194) 100%)' },
        { id: 'SteelGrey', name: 'SteelGrey', hex: '#97A2AC', gradient: 'radial-gradient(circle, rgb(151, 162, 172) 0%, rgb(99, 114, 124) 100%)' },
        { id: 'Strawberry', name: 'Strawberry', hex: '#DD8E6F', gradient: 'radial-gradient(circle, rgb(221, 142, 111) 0%, rgb(183, 90, 96) 100%)' },
        { id: 'TacticalPine', name: 'TacticalPine', hex: '#44826B', gradient: 'radial-gradient(circle, rgb(68, 130, 107) 0%, rgb(47, 99, 105) 100%)' },
        { id: 'Tomato', name: 'Tomato', hex: '#E6793E', gradient: 'radial-gradient(circle, rgb(230, 121, 62) 0%, rgb(212, 78, 63) 100%)' },
        { id: 'Turquoise', name: 'Turquoise', hex: '#5EC0B8', gradient: 'radial-gradient(circle, rgb(94, 192, 184) 0%, rgb(61, 146, 142) 100%)' },
    ];
    let giftTypes = [];
    const giftModels = [
        { id: 'm1', giftTypeId: 'type1', name: 'Темный кристалл', isMonocolor: true, imageUrl: 'PhotoGifts/Astral Shard/Amethyst.png' },
        { id: 'm2', giftTypeId: 'type1', name: 'Ледяной кристалл', isMonocolor: true, imageUrl: 'PhotoGifts/Astral Shard/Amethyst.png' },
        { id: 'm4', giftTypeId: 'type2', name: 'Мраморный ангел', isMonocolor: true, imageUrl: 'PhotoGifts/Astral Shard/Amethyst.png' },
        { id: 'm5', giftTypeId: 'type2', name: 'Базальтовый голем', isMonocolor: true, imageUrl: 'PhotoGifts/Astral Shard/Amethyst.png' },
        { id: 'm6', giftTypeId: 'type3', name: 'Шапка Санты', isMonocolor: false, imageUrl: 'PhotoGifts/Astral Shard/Amethyst.png' },
    ];

    const state = { // <-- А вот здесь 'state' только объявляется!
        bgFinder: {
            giftTypeId: null, modelId: null,
            targetColors: [],
            activeTargetIndex: 0
        },
        modelFinder: { giftTypeId: null, colorId: null, monocolorOnly: true }
    };

    
    const API_PHOTO_URL = 'https://cdn.changes.tg/gifts/models/'
    const SERVER_BASE_URL = 'https://nftapilocal20250728182647.azurewebsites.net';

    const API_ENDPOINTS = {
        getAllGiftNames: `${SERVER_BASE_URL}/api/ListGifts/AllGiftNames`,
        getAllModelNames: (giftName) => `${SERVER_BASE_URL}/api/ListGifts/${encodeURIComponent(giftName)}/AllModelNames`,
        getMainColors: (giftName, modelName) => `${SERVER_BASE_URL}/api/ListGifts/${encodeURIComponent(giftName)}/${encodeURIComponent(modelName)}/MainColors`
    };

    async function fetchAndPopulateGiftTypes() {
    try {
        const response = await fetch(API_ENDPOINTS.getAllGiftNames);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json(); // Ожидаем массив строк, например: ["Кристаллы", "Статуи", "Шапки"]

        // Преобразуем полученные строки в нужный формат { id: '...', name: '...' }
        // Генерируем простой ID на основе имени.
        giftTypes = data.map(name => ({
            id: name, // Пример генерации ID
            name: name
        }));

        console.log('Загружены типы подарков:', giftTypes);

        // Теперь, когда giftTypes заполнен, инициализируем выпадающий список для подарков
        // Предполагается, что у вас есть элемент с id="bgFinderGiftTypeDropdown"
        const giftTypeDropdownContainer = document.getElementById('bgFinderGiftTypeDropdown');
        if (giftTypeDropdownContainer) {
            createSearchableDropdown(
                giftTypeDropdownContainer,
                giftTypes,
                'Выберите тип подарка',
                onGiftTypeSelect // Функция-обработчик выбора подарка
            );
        } else {
            console.error('Контейнер для выбора типа подарка не найден (ID: bgFinderGiftTypeDropdown)');
        }

        const modelFinderGiftTypeDropdownContainer = document.getElementById('modelFinderGiftTypeDropdown');
        if (modelFinderGiftTypeDropdownContainer) {
            createSearchableDropdown(
                modelFinderGiftTypeDropdownContainer,
                giftTypes,
                'Выберите тип подарка',
                (type) => { // <-- ИСПОЛЬЗУЙТЕ ЭТУ ОБЕРТКУ!
                    state.modelFinder.giftTypeId = type.id; // Устанавливаем giftTypeId
                    findAndDisplayModels(); // И только потом вызываем findAndDisplayModels
                }
            );
        } else {
            console.error('Контейнер для выбора типа подарка (модели) не найден: modelFinderGiftTypeDropdown');
        }

        } catch (error) {
            console.error('Ошибка при загрузке типов подарков:', error);
            // Здесь можно показать сообщение об ошибке пользователю
            const giftTypeDropdownContainer = document.getElementById('bgFinderGiftTypeDropdown');
            if (giftTypeDropdownContainer) {
                giftTypeDropdownContainer.innerHTML = `<div class="text-muted text-center p-4">Ошибка загрузки типов подарков.</div>`;
            }
        }
    }

    let currentGiftModels = []; // [{ name: '...', imageUrl: '...', isMonocolor: true/false }]

    /**
     * Обрабатывает выбор типа подарка, загружает модели для него.
     */
    async function onGiftTypeSelect(selectedGiftType) {
        console.log('Выбран тип подарка:', selectedGiftType);
        state.bgFinder.giftTypeId = selectedGiftType.id;
        currentGiftModels = [];
        const modelDropdownContainer = document.getElementById('bgFinderModelDropdown');
        if (modelDropdownContainer) {
            modelDropdownContainer.updateItems([], 'Загрузка моделей...');
        }
        giftPreviewEl.classList.add('hidden');
        bgResultsContainer.innerHTML = '';
        targetColorsDisplay.innerHTML = '';

        try {
            // API_ENDPOINTS.getAllModelNames должен теперь возвращать Dictionary<string, bool>
            // Предполагается, что API_ENDPOINTS.getAllModelNames(selectedGiftType.name)
            // возвращает JSON-объект, например:
            // { "Аметист": true, "Рубин": false, "Модель с пробелом": true }
            const response = await fetch(API_ENDPOINTS.getAllModelNames(selectedGiftType.name));
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const data = await response.json(); // Ожидаем объект (словарь)

            // Преобразуем объект в массив объектов { id: '...', name: '...', isMonocolor: true/false }
            currentGiftModels = Object.entries(data).map(([name, isMonocolor]) => ({
                id: name,           // Имя как ID (сохраняя пробелы)
                name: name,         // Имя
                isMonocolor: isMonocolor // Добавляем флаг isMonocolor
            }));

            console.log(`Загружены модели для ${selectedGiftType.name}:`, currentGiftModels);

            if (modelDropdownContainer) {
                modelDropdownContainer.updateItems(currentGiftModels, `Выберите модель для ${selectedGiftType.name}`);
            }

            if (currentGiftModels.length === 1) {
                // Убедитесь, что onModelSelect может принимать объект с isMonocolor
                onModelSelect(currentGiftModels[0]);
            }

        } catch (error) {
            console.error(`Ошибка при загрузке моделей для ${selectedGiftType.name}:`, error);
            if (modelDropdownContainer) {
                modelDropdownContainer.updateItems([], `<div class="text-muted">Ошибка загрузки моделей.</div>`);
            }
        }
    }

    fetchAndPopulateGiftTypes();

    // --- Tab Logic ---
    document.querySelectorAll('.tab-btn').forEach(tab => {
        tab.addEventListener('click', () => {
            document.querySelectorAll('.tab-btn').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
            document.getElementById(tab.dataset.tab).classList.remove('hidden');
        });
    });

    // --- Function 1: Simulation ---
    let analyzeTimeout;
    const nftUrlInput = document.getElementById('nftUrlInput');
    const resultContainer = document.getElementById('monochromeResult');
    const urlStatus = document.getElementById('nftUrlStatus');
    function isValidUrl(url) {
        try {
            const u = new URL(url);
            return u.protocol === 'https:' && url.startsWith('https://t.me/nft/');
        } catch {
            return false;
        }
    }
    nftUrlInput.addEventListener('input', () => {
        clearTimeout(analyzeTimeout);
        const url = nftUrlInput.value.trim();
        if (!url) {
            urlStatus.textContent = '';
            resultContainer.innerHTML = `<span class="text-muted">Результат анализа появится здесь</span>`;
            return;
        }
        if (isValidUrl(url)) {
            urlStatus.innerHTML = '<span style="color: #38bdf8;">Корректная ссылка</span>';
            resultContainer.innerHTML = `<div class="loader mx-auto"></div>`;
            analyzeTimeout = setTimeout(() => {
                // Имитация анализа
                const isMonocolor = Math.random() > 0.5;
                const randomPercentage = isMonocolor ? (Math.random() * 10 + 90) : (Math.random() * 20 + 70);
                let html = `<div class="text-center">
                    <div class="text-5xl font-bold text-white">${randomPercentage.toFixed(1)}%</div>
                    <div class="text-lg text-text-secondary mt-1">Коэффициент монохромности</div>
                </div>`;
                if (!isMonocolor) {
                    html += `<p class="text-xs text-yellow-400 mt-2">Модель разноцветная. Коэффициент может быть неточным.</p>`;
                }
                resultContainer.innerHTML = html;
            }, 1000);
        } else {
            urlStatus.innerHTML = '<span style="color: #f87171;">Некорректная ссылка</span>';
            resultContainer.innerHTML = `<span class="text-muted">Результат анализа появится здесь</span>`;
        }
    });

    // --- Helper Functions ---
    const hexToRgb = (hex) => {
        const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return r ? { r: parseInt(r[1], 16), g: parseInt(r[2], 16), b: parseInt(r[3], 16) } : { r: 0, g: 0, b: 0 };
    };
    const colorDistance = (rgb1, rgb2) => Math.sqrt(Math.pow(rgb1.r - rgb2.r, 2) + Math.pow(rgb1.g - rgb2.g, 2) + Math.pow(rgb1.b - rgb2.b, 2));
    const createPlaceholderImgUrl = (hex, text = '') => {
        const clean = hex.replace('#', ''), rgb = hexToRgb(hex);
        const textColor = (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000 < 128 ? 'ffffff' : '000000';
        return `https://placehold.co/300x300/${clean}/${textColor}?text=${encodeURIComponent(text)}`;
    };

    const multicolorSvgIcon = `
            <svg class="multicolor-svg-icon" width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <rect x="2" y="2" width="20" height="20" rx="4" fill="#FF6363" fill-opacity="0.4" stroke="#CC0000" stroke-width="1.5"/>

                <path d="M12 18V18.5" stroke="#E90000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M12 14V8" stroke="#E90000" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>`;

    // --- Dropdown Factory ---
    function createSearchableDropdown(container, items, placeholder, onSelect) {
        container.innerHTML = `<input type="text" class="dropdown-input" placeholder="${placeholder}" readonly><div class="dropdown-options hidden"></div>`;
        const input = container.querySelector('.dropdown-input'), optionsContainer = container.querySelector('.dropdown-options');
        let currentSelection = null;

        const renderOptions = (filter = '') => {
            optionsContainer.innerHTML = '';
            const filtered = items.filter(i => i.name.toLowerCase().includes(filter.toLowerCase()));
            if (filtered.length === 0) { optionsContainer.innerHTML = `<div class="option-item text-muted">Ничего не найдено</div>`; }
            filtered.forEach(item => {
                const opt = document.createElement('div');
                opt.className = 'option-item';

                let colorSwatchHtml = '';
                if (item.gradient) {
                    colorSwatchHtml = `<span class="color-gradient-swatch" style="background-image: ${item.gradient};"></span>`;
                }
                
                let itemNameDisplay = item.name; 
                let multicolorBadgeHtml = '';
                if (item.hasOwnProperty('isMonocolor') && item.isMonocolor === false) {
                    // Использование SVG-значка
                    multicolorBadgeHtml = multicolorSvgIcon;
                }

                opt.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                        <div style="display: flex; align-items: center;">
                            ${colorSwatchHtml}
                            <span>${itemNameDisplay}</span>
                        </div>
                        ${multicolorBadgeHtml}
                    </div>
                `;
                
                if (currentSelection?.id === item.id) opt.classList.add('selected');
                opt.addEventListener('click', () => { currentSelection = item; input.value = item.name; toggleOptions(false); onSelect(item); });
                optionsContainer.appendChild(opt);
            });
        };

        const toggleOptions = (show) => {
            optionsContainer.classList.toggle('hidden', !show);
            if (show) { input.readOnly = false; input.value = ''; renderOptions(); input.focus(); } 
            else { input.readOnly = true; if (currentSelection) input.value = currentSelection.name; }
        };
        input.addEventListener('click', () => toggleOptions(true));
        input.addEventListener('input', () => renderOptions(input.value));
        document.addEventListener('click', (e) => !container.contains(e.target) && toggleOptions(false));
        container.updateItems = (newItems, newPlaceholder) => { items = newItems; input.placeholder = newPlaceholder; input.value = ''; currentSelection = null; renderOptions(); };
    }

    // --- Generic Render Logic ---
    const renderResults = (container, items, createCardHtml) => {
        container.innerHTML = '';
        if (items.length === 0) { container.innerHTML = `<p class="col-span-full text-center text-muted">Ничего не найдено.</p>`; return; }
        items.forEach(item => container.innerHTML += createCardHtml(item));
    };

    // --- Function 2: Background Finder ---
    const giftPreviewEl = document.getElementById('giftPreview');
    const previewImg = document.getElementById('giftPreviewImage');
    const canvas = document.getElementById('colorCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const targetColorsDisplay = document.getElementById('targetColorsDisplay');
    const bgResultsContainer = document.getElementById('backgroundResults');
    const modelStatusEl = document.getElementById('modelStatus');
    let findBackgroundsDebounceTimer;

    function setupDraggablePicker(picker, container, index) {
    let isDragging = false;
    let lastValidPosition = { left: picker.style.left, top: picker.style.top };

    // Добавляем превью цвета, если его нет
    let preview = picker.querySelector('.picker-color-preview');
    if (!preview) {
        preview = document.createElement('div');
        preview.className = 'picker-color-preview';
        // Стили для превью цвета (можно вынести в CSS)
        preview.style.position = 'absolute';
        preview.style.left = '50%';
        preview.style.top = '50%';
        preview.style.transform = 'translate(-50%, -50%)';
        preview.style.width = '18px';
        preview.style.height = '18px';
        preview.style.borderRadius = '50%';
        preview.style.border = '2px solid #fff';
        preview.style.boxShadow = '0 0 4px #0008';
        preview.style.pointerEvents = 'none';
        picker.appendChild(preview);
    }

    // Функция для обновления цвета под пипеткой
    function updateColorPreview() {
        const rect = container.getBoundingClientRect();
        const x = parseFloat(picker.style.left);
        const y = parseFloat(picker.style.top);
        const canvasX = Math.floor(x * (canvas.width / rect.width));
        const canvasY = Math.floor(y * (canvas.height / rect.height));
        const [r, g, b, a] = ctx.getImageData(canvasX, canvasY, 1, 1).data;
        const hex = `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
        preview.style.background = hex;
        // В реальном времени меняем цвет в state
        if (a >= 250) {
            state.bgFinder.targetColors[index] = hex;
            updateTargetColorsDisplay();
        }
    }

    const onMove = (clientX, clientY) => {
        if (!isDragging) return;

        updateColorPreview();

        // Затем запускаем/перезапускаем таймер debounce для поиска фонов
        clearTimeout(findBackgroundsDebounceTimer);
        findBackgroundsDebounceTimer = setTimeout(() => {
            findAndDisplayBackgrounds();
        }, 1500); // 5 секунд задержки

        const rect = container.getBoundingClientRect();
        let x = clientX - rect.left;
        let y = clientY - rect.top;
        x = Math.max(0, Math.min(rect.width, x));
        y = Math.max(0, Math.min(rect.height, y));
        picker.style.left = `${x}px`;
        picker.style.top = `${y}px`;
        updateColorPreview();
    };

    const onEnd = () => {
        if (!isDragging) return;
        isDragging = false;
        picker.classList.remove('dragging');
        const rect = container.getBoundingClientRect();
        const x = parseFloat(picker.style.left);
        const y = parseFloat(picker.style.top);
        const canvasX = Math.floor(x * (canvas.width / rect.width));
        const canvasY = Math.floor(y * (canvas.height / rect.height));
        const [r, g, b, a] = ctx.getImageData(canvasX, canvasY, 1, 1).data;

        if (a < 250) {
            picker.classList.add('invalid');
            setTimeout(() => picker.classList.remove('invalid'), 300);
            picker.style.left = lastValidPosition.left;
            picker.style.top = lastValidPosition.top;
            updateColorPreview();
            return;
        }

        lastValidPosition = { left: picker.style.left, top: picker.style.top };
        // После отпускания — поиск фонов
        //findAndDisplayBackgrounds();
    };

    picker.addEventListener('mousedown', (e) => { isDragging = true; picker.classList.add('dragging'); e.preventDefault(); });
    document.addEventListener('mousemove', (e) => onMove(e.clientX, e.clientY));
    document.addEventListener('mouseup', onEnd);
    picker.addEventListener('touchstart', (e) => { isDragging = true; picker.classList.add('dragging'); e.preventDefault(); }, { passive: false });
    document.addEventListener('touchmove', (e) => onMove(e.touches[0].clientX, e.touches[0].clientY));
    document.addEventListener('touchend', onEnd);

    // Инициализация цвета при создании
    //updateColorPreview();
}

// Создаем элемент уведомления ОДИН РАЗ при загрузке скрипта
let modelExplanationModal = document.getElementById('modelStatusExplanationModal');
let modelExplanationCloseBtn; // Для ссылки на кнопку закрытия

if (!modelExplanationModal) {
    modelExplanationModal = document.createElement('div');
    modelExplanationModal.id = 'modelStatusExplanationModal';
    modelExplanationModal.className = ''; // Пока без класса 'show'

    modelExplanationModal.innerHTML = `
        <div class="modal-content">
            <button class="close-btn" aria-label="Закрыть">&times;</button>
            <h3>Разноцветная модель</h3>
            <p>Данная модель не имеет четкого доминирующего цвета, из-за чего определение сочитающихся фонов может быть не корректным</p>
        </div>
    `;
    document.body.appendChild(modelExplanationModal);

    // Получаем ссылку на кнопку закрытия
    modelExplanationCloseBtn = modelExplanationModal.querySelector('.close-btn');

    // Добавляем слушатели событий для закрытия
    modelExplanationCloseBtn.addEventListener('click', closeModelExplanationModal);
    modelExplanationModal.addEventListener('click', (e) => {
        if (e.target === modelExplanationModal) { // Закрытие по клику на фон
            closeModelExplanationModal();
        }
    });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modelExplanationModal.classList.contains('show')) {
            closeModelExplanationModal();
        }
    });
} else {
    // Если элемент уже был в HTML (что мы договорились не делать, но на всякий случай)
    modelExplanationCloseBtn = modelExplanationModal.querySelector('.close-btn');
    if (modelExplanationCloseBtn) {
        modelExplanationCloseBtn.addEventListener('click', closeModelExplanationModal);
    }
    modelExplanationModal.addEventListener('click', (e) => {
        if (e.target === modelExplanationModal) {
            closeModelExplanationModal();
        }
    });
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modelExplanationModal.classList.contains('show')) {
            closeModelExplanationModal();
        }
    });
}


function openModelExplanationModal() {
    if (modelExplanationModal) {
        modelExplanationModal.classList.add('show');
        document.body.style.overflow = 'hidden'; // Запретить прокрутку фона
    }
}

function closeModelExplanationModal() {
    if (modelExplanationModal) {
        modelExplanationModal.classList.remove('show');
        // Вернуть прокрутку после небольшой задержки, чтобы анимация скрытия завершилась
        setTimeout(() => {
            document.body.style.overflow = '';
        }, 300); // Соответствует transition-duration в CSS
    }
}


// --- Обработчик клика для modelStatusEl (добавляется один раз!) ---
// Этот слушатель будет реагировать на клики по modelStatusEl
// независимо от того, какое содержимое у него внутри.
if (modelStatusEl) {
    modelStatusEl.addEventListener('click', (event) => {
        // Проверяем, что элемент активен (т.е. отображает статус "Разноцветная модель")
        if (modelStatusEl.classList.contains('active-status')) {
            openModelExplanationModal(); // Открываем наше новое поясняющее окно
            event.stopPropagation(); // Предотвращаем всплытие события, если modelStatusEl вложен
        }
    });
}


    async function renderGiftPreview(model) {
        if (!giftPreviewEl || !modelStatusEl /* || !previewImg */) {
        console.error("renderGiftPreview: Отсутствуют необходимые DOM-элементы!");
        return;
    }

    giftPreviewEl.classList.remove('hidden');

    if (model.isMonocolor) {
        // Если одноцветная, скрываем содержимое modelStatusEl и убираем активные классы
        modelStatusEl.innerHTML = ''; // Очищаем содержимое
        // Убираем все классы, включая active-status, так как плашка не должна быть кликабельной
        modelStatusEl.classList.remove('active-status', 'model-status-badge', 'multicolor');
        modelStatusEl.classList.add('hidden'); // Полностью скрываем элемент modelStatusEl
    } else {
        // Если разноцветная, выводим плашку с текстом и знаком вопроса
        // Важно: Теперь знак вопроса внутри той же плашки, но не имеет своего отдельного обработчика клика.
        // Вся плашка будет реагировать на клик.
        modelStatusEl.innerHTML = `
            <span class="model-status-badge multicolor">
                Разноцветная модель <span class="question-icon">?</span>
            </span>
        `;
        // Добавляем класс 'active-status' на САМ #modelStatusEl.
        // Этот класс будет использоваться для активации обработчика клика на modelStatusEl.
        modelStatusEl.classList.add('active-status');
        modelStatusEl.classList.remove('hidden'); // Показываем сам элемент modelStatusEl
    }

        const giftName = state.bgFinder.giftTypeId;
        const modelName = state.bgFinder.modelId;

        // Используем model.imageUrl если доступно, иначе конструируем путь
        previewImg.src = model.imageUrl || API_PHOTO_URL + `/${encodeURIComponent(giftName)}/png/${encodeURIComponent(modelName)}.png`;

        previewImg.onload = async () => {
            canvas.width = previewImg.naturalWidth;
            canvas.height = previewImg.naturalHeight;
            ctx.drawImage(previewImg, 0, 0);

            const container = document.querySelector('.gift-preview-container');
            // Очищаем существующие пипетки перед добавлением новых
            container.querySelectorAll('.color-picker').forEach(p => p.remove());

            // Вызываем новую функцию для получения и парсинга цветов
            const mainColorsData = await fetchAndParseMainColors(giftName, modelName);

            // Используем полученные данные для позиционирования пипеток
            const imgWidth = previewImg.naturalWidth;
            const imgHeight = previewImg.naturalHeight;

            // Определяем количество пипеток: используем либо полученные данные, либо 3 по умолчанию
            const positionsToUse = mainColorsData.length > 0 ? mainColorsData : [
                // Заглушки, если нет данных или возникла ошибка при загрузке
                {x: '30%', y: '30%', hex: '#FFFFFF'},
                {x: '70%', y: '50%', hex: '#888888'},
                {x: '40%', y: '75%', hex: '#000000'}
            ];

            // Ограничиваем количество пипеток до 3, если данных больше (или если заглушки)
            for (let i = 0; i < Math.min(positionsToUse.length, 3); i++) {
                const data = positionsToUse[i];
                const picker = document.createElement('div');
                picker.className = 'color-picker';

                let posX, posY;
                let initialColor;

                if (typeof data.x === 'number' && typeof data.y === 'number') {
                    // Если данные с сервера (абсолютные пиксели), конвертируем в проценты
                    posX = (data.x / imgWidth) * 100 + '%';
                    posY = (data.y / imgHeight) * 100 + '%';
                    initialColor = data.hex;
                } else {
                    // Если это заглушки с процентами, используем их напрямую
                    posX = data.x;
                    posY = data.y;
                    initialColor = data.hex;
                }

                picker.style.left = posX;
                picker.style.top = posY;
                picker.style.backgroundColor = initialColor; // Устанавливаем цвет пипетки напрямую
                picker.dataset.initialColor = initialColor; // Также сохраняем его в dataset для других целей
                state.bgFinder.targetColors[i] = initialColor; // Обновляем состояние с цветами
                console.log('Цвет пипетки:', initialColor, 'позиция:', posX, posY);

                container.appendChild(picker);
                setupDraggablePicker(picker, container, i);
                // Если setupDraggablePicker сам берет цвет с канваса,
                // или вы используете picker.dataset.initialColor для установки цвета.
                // Если нужно, чтобы пипетка сразу взяла цвет с канваса в этой позиции:
                // picker.dispatchEvent(new MouseEvent('mouseup'));
            }

            updateTargetColorsDisplay();
            findAndDisplayBackgrounds();
        };
    }
    
    async function fetchAndParseMainColors(giftName, modelName) {
        let mainColorsData = [];
        try {
            const colorsResponse = await fetch(`${SERVER_BASE_URL}/api/ListGifts/${encodeURIComponent(giftName)}/${encodeURIComponent(modelName)}/MainColors`);

            if (!colorsResponse.ok) {
                throw new Error(`Ошибка HTTP при получении основных цветов: ${colorsResponse.status} ${colorsResponse.statusText}`);
            }

            const colorsString = await colorsResponse.text();

            if (colorsString) {
                mainColorsData = colorsString.split(';').map(item => {
                    const trimmedItem = item.trim();
                    if (!trimmedItem) return null;

                    const parts = trimmedItem.split(':');
                    if (parts.length !== 2) {
                        console.warn(`Неверный формат элемента цвета: "${trimmedItem}"`);
                        return null;
                    }

                    const posPart = parts[0];
                    const hexPart = parts[1];

                    const xMatch = posPart.match(/X=(\d+)/);
                    const yMatch = posPart.match(/Y=(\d+)/);

                    const x = xMatch ? parseInt(xMatch[1], 10) : 0;
                    const y = yMatch ? parseInt(yMatch[1], 10) : 0;
                    const hex = '#' + hexPart;

                    return { x, y, hex };
                }).filter(item => item !== null);
            }

            console.log("Получены и распарсены основные цвета:", mainColorsData);
            return mainColorsData;

        } catch (error) {
            console.error('Ошибка при загрузке основных цветов модели:', error);
            // Возвращаем пустой массив или массив с заглушками в случае ошибки
            return [
                {x: 0, y: 0, hex: '#FFFFFF'}, // Будут пересчитаны в проценты ниже
                {x: 0, y: 0, hex: '#888888'},
                {x: 0, y: 0, hex: '#000000'}
            ];
        }
    }

    function updateTargetColorsDisplay() {
        targetColorsDisplay.innerHTML = '';
        state.bgFinder.targetColors.forEach((hex, index) => {
            const swatch = document.createElement('div');
            swatch.className = 'color-swatch';
            //if (index === state.bgFinder.activeTargetIndex) swatch.classList.add('active');
            swatch.style.backgroundColor = hex;
            swatch.innerHTML = `<span class="color-swatch-hex">${hex.toUpperCase()}</span>`;
            targetColorsDisplay.appendChild(swatch);
        });
    }

    async function findAndDisplayBackgrounds() {
        const bgResultsContainer = document.getElementById('backgroundResults');

        if (!bgResultsContainer) {
            console.error("Элемент с ID 'backgroundResults' не найден в DOM!");
            return;
        }

        const currentScrollTop = bgResultsContainer.scrollTop;

        const selectedGiftTypeId = state.bgFinder.giftTypeId;
        const selectedModelId = state.bgFinder.modelId;
        const targetColors = state.bgFinder.targetColors;

        let apiUrl = '';
        let requestBody = {};

        try {
            if (targetColors && Array.isArray(targetColors) && targetColors.length === 3 && targetColors.every(c => typeof c === 'string' && c.startsWith('#'))) {
                apiUrl = SERVER_BASE_URL + '/api/MonoCoof/TopBackgroundColorsByColors';
                requestBody = {
                    colors: targetColors
                };
                console.log("Используем API по 3 цветам:", targetColors);
            } else {
                if (!selectedGiftTypeId || !selectedModelId) {
                    bgResultsContainer.innerHTML = `<p class="col-span-full text-center text-muted">Сначала выберите тип подарка и модель.</p>`;
                    bgResultsContainer.scrollTop = currentScrollTop;
                    return;
                }
                apiUrl = SERVER_BASE_URL + '/api/MonoCoof/TopBackgroundColorsByNFT';
                requestBody = {
                    nameGift: selectedGiftTypeId,
                    nameModel: selectedModelId
                };
                console.log("Используем API по типу подарка/модели:", selectedGiftTypeId, selectedModelId);
            }

            console.log("Запрос", requestBody);

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorText = await response.text();
                bgResultsContainer.innerHTML = `<p class="col-span-full text-center text-danger">Ошибка HTTP: ${response.status} ${response.statusText} - ${errorText}</p>`;
                bgResultsContainer.scrollTop = currentScrollTop;
                throw new Error(`Ошибка HTTP: ${response.status} ${response.statusText} - ${errorText}`);
            }

            const serverData = await response.json();

            if (!serverData || serverData.length === 0) {
                bgResultsContainer.innerHTML = `<p class="col-span-full text-center text-muted">Подходящих фонов не найдено.</p>`;
                bgResultsContainer.scrollTop = currentScrollTop;
                return;
            }

            const enrichedBgs = serverData.map(serverItem => {
                const colorNameFromServer = serverItem.key;
                const compatibilityValue = serverItem.value;

                const foundFixedColor = fixedColors.find(fc => fc.name === colorNameFromServer);

                if (foundFixedColor) {
                    return {
                        ...foundFixedColor,
                        compatValue: compatibilityValue
                    };
                }
                console.warn(`Цвет "${colorNameFromServer}" с сервера не найден в локальном fixedColors.`);
                return {
                    id: colorNameFromServer.toLowerCase(),
                    name: colorNameFromServer,
                    hex: '#CCCCCC',
                    gradient: 'linear-gradient(to right, #CCCCCC, #AAAAAA)',
                    compatValue: compatibilityValue
                };
            });

            // Внимание: здесь мы используем modelId и giftTypeId из `state.bgFinder`
            // Так как эти карточки отображают ФОНЫ для выбранной МОДЕЛИ.
            // Поэтому, modelName и giftName будут относиться к ВЫБРАННОЙ модели.
            const modelNameForBackground = selectedModelId;
            const giftTypeNameForBackground = selectedGiftTypeId;

            // Если выводится фон, то на нем всегда статичная модель.
            // Для этой статичной модели мы можем определить, является ли она монохромной
            // (например, если у вас есть данные о моделях, или если вы знаете,
            // что все модели, используемые в качестве "предмета" на фонах, являются монохромными).
            // Если такой информации нет, `isMonocolor` для фона-карточки всегда будет `true` (или отсутствовать).
            // Для простоты, здесь мы предполагаем, что на фоне всегда "модель",
            // и ее `isMonocolor` значение может быть извлечено из `state.bgFinder.isMonocolor`
            // или если вы передаете этот параметр в модель (что лучше).
            // В данном контексте, карточка фона несет информацию о ФОНЕ, а не о модели,
            // но чтобы `openCardModal` мог работать единообразно,
            // мы все равно передадим `modelName` и `giftTypeId` из `state.bgFinder`.

            // finalModelImageUrl содержит URL PNG изображения модели для отображения на фоне
            const finalModelImageUrl = API_PHOTO_URL + `/${encodeURIComponent(selectedGiftTypeId)}/png/${encodeURIComponent(selectedModelId)}.png`;

            const fragment = document.createDocumentFragment();

            enrichedBgs.forEach(color => {
                const compatPercentage = (color.compatValue * 100).toFixed(0);

                // --- КЛЮЧЕВОЕ ИЗМЕНЕНИЕ: ДОБАВЛЯЕМ data-АТРИБУТЫ К КАРТОЧКЕ ---
                // Теперь карточка фона также содержит данные о модели и подарке,
                // что позволяет openCardModal единообразно работать.
                const cardHtml = `
                    <div class="card" 
                        data-gift-id="${encodeURIComponent(giftTypeNameForBackground)}"
                        data-model-name="${encodeURIComponent(modelNameForBackground)}"
                        data-color-name="${encodeURIComponent(color.name)}"
                        data-is-monocolor="true"> 
                        <div class="card-visual-area" style="background-image: ${color.gradient};">
                            <img src="${finalModelImageUrl}" alt="Модель на фоне ${color.name}" loading="lazy">
                        </div>
                        <div class="card-info">
                            <h3 class="font-semibold text-sm truncate flex justify-between items-center">
                                <span>${color.name}</span>
                            </h3>
                            <p class="text-xs text-text-secondary">Совместимость: ${compatPercentage}%</p>
                        </div>
                    </div>`;

                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = cardHtml.trim();

                if (tempDiv.firstChild) {
                    const cardElement = tempDiv.firstChild;
                    cardElement.addEventListener('click', () => {
                        openCardModal(cardElement.outerHTML); // Передаем outerHTML кликнутой карточки
                    });
                    fragment.appendChild(cardElement);
                } else {
                    console.error('Failed to create DOM element from cardHtml:', cardHtml);
                }
            });

            while (bgResultsContainer.firstChild) {
                bgResultsContainer.removeChild(bgResultsContainer.firstChild);
            }

            bgResultsContainer.appendChild(fragment);
            bgResultsContainer.scrollTop = currentScrollTop;

        } catch (error) {
            console.error('Ошибка при получении фонов с сервера:', error);
            bgResultsContainer.innerHTML = `<p class="col-span-full text-center text-danger">Не удалось загрузить фоны. Попробуйте снова. (${error.message})</p>`;
            bgResultsContainer.scrollTop = currentScrollTop;
        }
    }

    // --- Function 3: Model Finder ---
    const monocolorOnlyCheckbox = document.getElementById('monocolorOnlyCheckbox');
    monocolorOnlyCheckbox.addEventListener('input', () => {
        state.modelFinder.monocolorOnly = monocolorOnlyCheckbox.checked;
        findAndDisplayModels();
    });

    async function findAndDisplayModels() {
    const { giftTypeId, colorId, monocolorOnly } = state.modelFinder;
    console.log('Поиск моделей с параметрами:', { giftTypeId, colorId, monocolorOnly });

    const container = document.getElementById('modelResults');
    if (!container) {
        console.error("Элемент с ID 'modelResults' не найден в DOM!");
        return;
    }

    const currentScrollTop = container.scrollTop;

    try {
        const selectedColor = fixedColors.find(c => c.id === colorId);
        if (!selectedColor) {
            container.innerHTML = `<p class="col-span-full text-center text-danger">Выбранный цвет не найден.</p>`;
            container.scrollTop = currentScrollTop;
            console.error(`Цвет с ID ${colorId} не найден в fixedColors.`);
            return;
        }
        const nameColorToSend = selectedColor.name;

        const response = await fetch(SERVER_BASE_URL + '/api/MonoCoof/TopNftByColor', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                nameGift: giftTypeId,
                nameColor: nameColorToSend,
                monohromeModelsOnly: monocolorOnly
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            container.innerHTML = `<p class="col-span-full text-center text-danger">Ошибка HTTP: ${response.status} ${response.statusText} - ${errorText}</p>`;
            container.scrollTop = currentScrollTop;
            throw new Error(`Ошибка HTTP: ${response.status} ${response.statusText} - ${errorText}`);
        }

        const serverData = await response.json();

        if (!serverData || serverData.length === 0) {
            container.innerHTML = `<p class="col-span-full text-center text-muted">Подходящих моделей не найдено для выбранных параметров.</p>`;
            container.scrollTop = currentScrollTop;
            return;
        }

        const modelsToRender = serverData.map(serverItem => {
            const modelName = serverItem.name;
            const compatibilityValue = serverItem.coof;
            const isMonohrome = serverItem.isMonohrome;

            const foundColorData = fixedColors.find(fc => fc.name === state.modelFinder.colorId);
            const modelGradient = foundColorData ? foundColorData.gradient : 'linear-gradient(to right, #CCCCCC, #AAAAAA)';

            return {
                name: modelName,
                compatValue: compatibilityValue,
                isMonohrome: isMonohrome,
                giftTypeId: giftTypeId, // Уже есть
                gradient: modelGradient, // Уже есть
                // Дополнительные данные, которые будут в cardHtml data-атрибутах
                colorName: nameColorToSend // Сохраняем имя цвета для data-атрибута
            };
        });

        modelsToRender.sort((a, b) => b.compatValue - a.compatValue);

        const fragment = document.createDocumentFragment();

        modelsToRender.forEach(model => {
            const compatPercentage = (model.compatValue * 100).toFixed(0);
            const modelStatusBadge = !model.isMonohrome
                ? multicolorSvgIcon // Эта переменная должна содержать полный HTML для значка
                : '';
            const imageUrl = API_PHOTO_URL + `/${encodeURIComponent(model.giftTypeId)}/png/${encodeURIComponent(model.name)}.png`;

            // --- КЛЮЧЕВОЕ ИЗМЕНЕНИЕ: ДОБАВЛЯЕМ data-АТРИБУТЫ К КАРТОЧКЕ ---
            const cardHtml = `
                <div class="card" 
                     data-gift-id="${encodeURIComponent(model.giftTypeId)}"
                     data-model-name="${encodeURIComponent(model.name)}"
                     data-color-name="${encodeURIComponent(model.colorName)}"
                     data-is-monocolor="${model.isMonohrome ? 'true' : 'false'}">
                    <div class="card-visual-area" style="background-image: ${model.gradient};">
                        <img src="${imageUrl}" alt="${model.name}" loading="lazy">
                    </div>
                    <div class="card-info">
                        <h3 class="font-semibold text-sm truncate flex justify-between items-center">
                            <span>${model.name}</span> ${modelStatusBadge}
                        </h3>
                        <p class="text-xs text-text-secondary">Совместимость: ${compatPercentage}%</p>
                    </div>
                </div>`;

            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = cardHtml.trim();

            if (tempDiv.firstChild) {
                // Добавляем слушатель клика к самой карточке
                const cardElement = tempDiv.firstChild;
                cardElement.addEventListener('click', () => {
                    openCardModal(cardElement.outerHTML); // Передаем outerHTML кликнутой карточки
                });
                fragment.appendChild(cardElement);
            } else {
                console.error('Failed to create DOM element from cardHtml (likely due to invalid HTML or empty string):', cardHtml);
            }
        });

        while (container.firstChild) {
            container.removeChild(container.firstChild);
        }

        container.appendChild(fragment);
        container.scrollTop = currentScrollTop;

    } catch (error) {
        console.error('Ошибка при получении моделей с сервера:', error);
        container.innerHTML = `<p class="col-span-full text-center text-danger">Не удалось загрузить модели. Попробуйте снова. (${error.message})</p>`;
        container.scrollTop = currentScrollTop;
    }
}

    // --- Init ---
    function init() {
        const bgFinderGiftTypeDD = document.getElementById('bgFinderGiftTypeDropdown');
        const bgFinderModelDD = document.getElementById('bgFinderModelDropdown');
        createSearchableDropdown(bgFinderGiftTypeDD, giftTypes, 'Выберите тип...', (type) => {
            state.bgFinder.giftTypeId = type.id;
            giftPreviewEl.classList.add('hidden');
            bgResultsContainer.innerHTML = `<p class="col-span-full text-center text-muted">Выберите модель</p>`;
            targetColorsDisplay.innerHTML = '';
            bgFinderModelDD.updateItems(giftModels.filter(m => m.giftTypeId === type.id), 'Выберите модель...');
        });
        createSearchableDropdown(bgFinderModelDD, [], 'Сначала выберите тип', (model) => {
            state.bgFinder.modelId = model.id;
            renderGiftPreview(model);
        });

        const modelFinderGiftTypeDD = document.getElementById('modelFinderGiftTypeDropdown');
        const modelFinderColorDD = document.getElementById('modelFinderColorDropdown');
        createSearchableDropdown(modelFinderGiftTypeDD, giftTypes, 'Выберите тип...', (type) => { state.modelFinder.giftTypeId = type.id; findAndDisplayModels(); });
        createSearchableDropdown(modelFinderColorDD, fixedColors, 'Выберите цвет...', (color) => { state.modelFinder.colorId = color.id; findAndDisplayModels(); });

        bgResultsContainer.innerHTML = `<p class="col-span-full text-center text-muted">Выберите тип и модель</p>`;
        document.getElementById('modelResults').innerHTML = `<p class="col-span-full text-center text-muted">Выберите тип и цвет</p>`;
    }

    init();

    // --- Модальное окно для карточки ---
    const cardModalOverlay = document.getElementById('cardModalOverlay');
    const cardModalContent = document.getElementById('cardModalContent');
    const closeModalBtn = document.getElementById('closeModalBtn');
    const modalBodyContent = document.getElementById('modalBodyContent'); // Новая ссылка на элемент


    // --- Функция для закрытия модального окна (модифицирована для остановки Lottie) ---
function closeCardModal() {
    cardModalOverlay.style.display = 'none';
    modalBodyContent.innerHTML = ''; // Очищаем содержимое при закрытии

    // Остановка Lottie-анимации, если она была загружена
    if (window.currentLottieAnimation) {
        window.currentLottieAnimation.destroy(); // Удаляем анимацию из DOM и памяти
        window.currentLottieAnimation = null; // Сбрасываем ссылку
    }

    document.body.style.overflow = '';
}

// --- Обработчики событий для закрытия модального окна (без изменений) ---
closeModalBtn.onclick = closeCardModal;
cardModalOverlay.onclick = function(e) {
    if (e.target === cardModalOverlay) closeCardModal();
};
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') closeCardModal();
});


// --- Функция openCardModal (МОДИФИЦИРОВАННАЯ!) ---
    function openCardModal(cardHtml) {
    // 1. Создаем временный div для парсинга HTML
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = cardHtml.trim();
    const cardElement = tempDiv.querySelector('.card'); // Получаем саму карточку

    if (!cardElement) {
        console.error("openCardModal: Элемент .card не найден в переданном HTML.");
        return;
    }

    // 2. Извлекаем данные из data-атрибутов карточки
    const giftTypeId = decodeURIComponent(cardElement.dataset.giftId || 'Неизвестно');
    const modelName = decodeURIComponent(cardElement.dataset.modelName || 'Неизвестно');
    const colorName = decodeURIComponent(cardElement.dataset.colorName || 'Неизвестно');
    const isMonocolor = cardElement.dataset.isMonocolor === 'true'; // Преобразуем строку в булево значение
    
    // Определяем тип карточки (модель или фон) для более точной логики отображения Lottie/PNG
    // Если вы добавили data-card-type в findAndDisplayBackgrounds, используйте его:
    // const cardType = cardElement.dataset.cardType || 'model'; // 'model' или 'background'

    // Извлекаем другие данные, как раньше:
    const cardVisualArea = cardElement.querySelector('.card-visual-area');
    const cardImg = cardVisualArea ? cardVisualArea.querySelector('img') : null;
    const cardCompatibilityP = cardElement.querySelector('.card-info p');

    let gradient = '';
    let imageUrl = ''; // URL изображения PNG
    let lottieAnimationUrl = ''; // URL Lottie JSON
    let compatibility = '0%';

    if (cardVisualArea && cardVisualArea.style.backgroundImage) {
        gradient = cardVisualArea.style.backgroundImage;
    }
    
    if (cardImg && cardImg.src) {
        imageUrl = cardImg.src; // Получаем URL PNG изображения
        
        // --- ГЕНЕРИРУЕМ URL LOTTIE АНИМАЦИИ ---
        const parts = imageUrl.split('/');
        const fileNameWithExt = parts.pop();
        const fileName = fileNameWithExt.split('.')[0];
        
        const pngIndex = parts.indexOf('png');
        if (pngIndex !== -1) {
            parts[pngIndex] = 'lottie';
            lottieAnimationUrl = parts.join('/') + '/' + fileName + '.json';
        } else {
            console.warn("Папка 'png' не найдена в URL изображения. Lottie URL может быть неверным.", imageUrl);
            // Если вы уверены, что для background карточек Lottie не будет,
            // здесь можно добавить проверку: `if (cardType === 'model') { ... }`
        }
    }
    
    if (cardCompatibilityP) {
        compatibility = cardCompatibilityP.textContent.replace('Совместимость: ', '').trim();
    }

    // --- ФОРМИРУЕМ ПЛАШКУ СТАТУСА ДЛЯ МОДАЛЬНОГО ОКНА ---
    // Используем `isMonocolor` из data-атрибута.
    // Если isMonocolor == false, значит это "разноцветная" модель, и мы выводим плашку.
    const modelStatusBadgeForModal = !isMonocolor 
        ? `<span class="model-status-badge multicolor">
                Разноцветная модель <span class="question-icon">?</span>
            </span>`
        : '';


    // 3. Формируем новый HTML для содержимого модального окна
    const modalContentHtml = `
        <div class="modal-visual-area" style="background-image: ${gradient};">
            <div id="lottieAnimationContainer" style="width: 80%; height: 80%; object-fit: contain;"></div>
        </div>
        ${modelStatusBadgeForModal ? `<div id="modelStatusInModal" class="modal-status-container">${modelStatusBadgeForModal}</div>` : ''}
        <div class="modal-info-details">
            <p><strong>Имя подарка:</strong> ${giftTypeId}</p>
            <p><strong>Имя модели:</strong> ${modelName}</p>
            <p><strong>Цвет:</strong> ${colorName}</p>
            <p><strong>Совместимость:</strong> ${compatibility}</p>
        </div>
    `;

    modalBodyContent.innerHTML = modalContentHtml;

    cardModalOverlay.style.display = 'flex';
    document.body.style.overflow = 'hidden';

    // 4. Загрузка Lottie-анимации (без изменений в этой части)
    if (lottieAnimationUrl) {
        const lottieContainer = document.getElementById('lottieAnimationContainer');
        if (lottieContainer) {
            if (window.currentLottieAnimation) {
                window.currentLottieAnimation.destroy();
                window.currentLottieAnimation = null;
            }

            window.currentLottieAnimation = lottie.loadAnimation({
                container: lottieContainer,
                renderer: 'svg',
                loop: true,
                autoplay: true,
                path: lottieAnimationUrl
            });
        }
    } else {
        const currentVisualArea = modalBodyContent.querySelector('.modal-visual-area');
        if (currentVisualArea && imageUrl) {
             currentVisualArea.innerHTML = `<img src="${imageUrl}" alt="${modelName}" style="width:100%; height:100%; object-fit: contain;">`;
        }
    }

    // --- КЛЮЧЕВОЕ ИЗМЕНЕНИЕ: ДОБАВЛЯЕМ СЛУШАТЕЛЬ К ПЛАШКЕ ВНУТРИ МОДАЛКИ ---
    // Используем setTimeout 0, чтобы элемент успел появиться в DOM
    setTimeout(() => {
        const modelStatusInModal = document.getElementById('modelStatusInModal');
        if (modelStatusInModal) {
            // Прикрепляем слушатель клика к контейнеру плашки
            modelStatusInModal.addEventListener('click', (event) => {
                // Убедимся, что клик был по самой плашке или её содержимому
                if (modelStatusInModal.querySelector('.model-status-badge.multicolor')) {
                     openModelExplanationModal(); // Открываем то самое поясняющее окно
                     event.stopPropagation(); // Предотвращаем всплытие
                }
            });
        }
    }, 0); // Небольшая задержка, чтобы элемент успел быть в DOM
}

    // --- Обертка для клика по карточке ---
    function makeCardsOpenable(containerId) {
        const container = document.getElementById(containerId);
        container.addEventListener('click', function(e) {
            let card = e.target.closest('.card');
            if (card) {
                openCardModal(card.outerHTML);
            }
        });
    }
    makeCardsOpenable('backgroundResults');
    makeCardsOpenable('modelResults');
});
</script>
</body>
</html>
